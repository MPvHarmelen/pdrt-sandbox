\section{Building Projective Discourse Representation Structures}

% nice introduction

\subsection{Basic Structures and Subordination}

We define basic DRSs following \citeasnoun{bos2003implementing}, with the
exception that equality between variables (i.e., $x_1=x_2$) is not
a separate DRS condition, but is treated as a variant of a 2-place predicate
(i.e., $R(x_1,x_2)$, where $R$ equals $=$). This definition basically
follows the definition proposed by \citeasnoun{kamp1993discourse}, without
their duplex conditions, in order to allow for a direct translation to
first-order logic.

\begin{definition}[Basic DRS] \label{def:bDRS}~\\
A Basic DRS is a tuple $\langle \{x_1 ... x_n\},\{\gamma_1 ... \gamma_m\} 
\rangle$, where:
 \begin{enumerate}[i.]
  \item $\{x_1 ... x_n\}$ is a finite set of variables (called ``DRS
    referents'');
  \item $\{\gamma_1 ... \gamma_m\}$ is a finite set of DRS conditions (which
    may be either basic or complex);
  \item\label{def:bDRS:Rel} $R(x_1, ..., x_n)$ is a basic DRS condition,
    with $x_1 ... x_n$ are variables and $R$ is a relation symbol for an
    $n$-place predicate;
  \item $\neg K$, $\Box K$ and $\Diamond K$ are complex DRS conditions, with
    $K$ is a DRS;
  \item $K_1 \vee K_2$ and $K_1 \Rightarrow K_2$ are complex DRS conditions,
    with $K_1$ and $K_2$ are DRSs;
  \item \label{def:bDRS:Prop} $x:K$ is a complex DRS condition, with $x$ is
    a variable and $K$ is a DRS.
 \end{enumerate} 
\end{definition}

% set of referents is DRS universe
%%more explanation?

The main difference between a basic DRS and a basic PDRS is that in PDRT all
structures introduce a label, which can accordingly bind the pointers
associated with the PDRS referents and conditions. We will refer to labels
and pointers together as \textit{projection variables}. This description
results in the definition of a PDRS as a triple of a projection variable,
a set of projected referents (i.e., DRS referents associated with a pointer)
and a set of projected conditions. However, such a definition omits an
essential part of the information that is required to properly represent
projection phenomena, namely their \emph{projection path}. In DRT, the
projection path (or ``projection line'', as
\citeasnoun{sandt1992presupposition} calls it) of some projected content
determines which DRSs are accessible from the introduction site to find
a possible antecedent in or otherwise to accommodate into. Accessibility
between DRSs is standardly defined based on a subordination relation
($\leq$) between DRSs, i.e., DRS $K_1$ is accessible from DRS $K_2$
\textit{iff} $K_2\leq K_1$, where subordination is recursively defined as
follows:

\begin{definition}[DRS Subordination]\label{def:DRSsub}~\\
DRS $K_1$ subordinates DRS $K_2$ ($K_2 \leq K_1$) iff:
  \begin{itemize}
    \item $K_1 = K_2$;
    \item $K_1$ directly subordinates $K_2$ ($K_2 <!~K_1$);
    \item There is a DRS $K_{1'}$, such that $K_{1'} \leq K_1$ and 
      $K_2 \leq K_{1'}$.
  \end{itemize}
  \end{definition}

\noindent Thus, a DRS is always subordinated by itself, and by any DRS that
directly, or indirectly subordinates it. Direct subordination between two
DRSs $K_1$ and $K_2$ means that $K_2$ is either part of a condition in
$K_1$, or that $K_1$ serves as its antecedent in some binary operation. This
is formally defined below.

\begin{definition}[DRS Direct Subordination]~\\
DRS $K_i$ directly subordinates DRS $K_j$ ($K_j <!~K_i$) iff:
  \begin{itemize}
    \item $\neg K_j$, $\Box K_j$ or $\Diamond K_j$ is a DRS condition in
      $K_i$;
    \item $x:K_j$ is a DRS condition in $K_i$ for some $x$;
    \item $K_j \Rightarrow K_k$, $K_k \Rightarrow K_j$, $K_j \vee K_k$, or 
      $K_k \vee K_j$ is a DRS condition in $K_i$ for some DRS $K_k$;
    \item There is a DRS $K_k$, such that $K_i \Rightarrow K_j$ or $K_i \vee K_j$
      is a DRS condition in $K_k$.
  \end{itemize}
\end{definition}

Now, in order to properly define accessibility in PDRT, we need to take into
account the contexts introduced by the projection pointers.  In case
a pointer occurs free, it introduces a projected context, whose
accessibility conditions are undefined, except for the fact that this
context needs to be accessible from the context in which it was introduced,
since the interpretation site of some linguistic content is necessarily
accessible from its introduction site. Moreover, projected contexts may
subordinate other projected contexts, which happens for example in the case
of embedded presuppositions. So, in order to properly define the projection
path of projected content in PDRT, the subordination properties of projected
contexts should be explicitly part of the PDRS. We do this by enhancing each
PDRS with a set of \MAPs: Minimally Accessible Projected contexts, which are
basically tuples describing pairs of  subordinating contexts. This results
in the following definition of basic PDRSs:

\begin{definition}[Basic PDRS] \label{def:bPDRS}~\\
A Basic PDRS is a quadruple $\langle \rho, \{\mu_1 ... \mu_n\}, 
\{\delta_1 ... \delta_m\}, \{\chi_1 ... \chi_l\}\rangle$, where:
  \begin{enumerate}[i.]
    \item $\rho$ is a projection variable;
    \item $\{\mu_1 ... \mu_n\}$ is a finite set of \MAPs, with $\mu_i=\langle
      v_1,v_2\rangle$, and  $v_1$ and $v_2$ are projection variables;
    \item $\{\delta_1 ... \delta_m\}$ is a finite set of projected
      referents, with $\delta_j=\langle v_j, x_j\rangle$, such that $v_j$ is
      a projection variable, and $x_j$ is a DRS referent;
    \item $\{\chi_1 ... \chi_l\}$ is a finite set of projected conditions,
      with $\chi_k = \langle v_k,\gamma_k\rangle$, such that $v_k$ is a
      projection variable, and $\gamma_k$ is a PDRS condition (which may be
      either basic or complex);
    \item \label{def:bPDRS:Rel} $R(x_1, ..., x_n)$ is a basic PDRS condition,
      with $x_1 ... x_n$ are variables and $R$ is a relation symbol for an
      $n$-place predicate;
    \item $\neg P$, $\Box P$ and $\Diamond P$ are complex PDRS conditions,
      with $P$ is a PDRS;
    \item $P_1 \vee P_2$ and $P_1 \Rightarrow P_2$ are complex PDRS
      conditions, with $P_1$ and $P_2$ are PDRSs;
    \item\label{def:bPDRS:Prop} $x:P$ is a complex PDRS condition, with $x$
      is a variable and $P$ is a PDRS;
  \end{enumerate}
\end{definition}

\noindent Note the direct correspondence between Definition
\ref{def:bPDRS}(\ref{def:bPDRS:Rel}-\ref{def:bPDRS:Prop}) and Definition
\ref{def:bDRS}(\ref{def:bDRS:Rel}-\ref{def:bDRS:Prop}); the only difference
is that complex PDRS conditions contain subordinated PDRSs, and complex DRS
conditions contain subordinated DRSs.  The definition of projected referents
and projected conditions as tuples allows us to talk about the two elements
of the tuples separately; we refer to the first element of all projected
referents and projected conditions as the \textit{pointer}, and the second
elements are called the \textit{PDRS referent} and \textit{PDRS condition},
respectively. This is useful, since in some cases we are interested in the
entire projected referent/condition, whereas in other cases we need only to
refer to one of the elements of the tuple. Similarly, we refer to the first
element of the quadruple representing a PDRS, as the \textit{label} of the
PDRS (formally, the label of a PDRS $P_i$ is represented as $\rho(P_i)$).

Now we can define subordination for PDRSs. As described above, we need to
consider both sub-PDRSs and projected contexts when defining accessibility.
Therefore, we define accessibility over \textit{PDRS-contexts} instead of
PDRSs. A PDRS-context may refer to a PDRS (via its label), or to
a projected context created by a pointer.

\begin{definition}[PDRS-context Subordination]~\\
PDRS-context $\pi_1$ subordinates PDRS-context $\pi_2$ ($\pi_2 \leq \pi_1$)
iff:
\begin{itemize}
  \item $\pi_1 = \pi_2$;
  \item $\pi_1$ directly subordinates $\pi_2$ ($\pi_2 <!~\pi_1$);
  \item $\pi_1$ is a minimally accessible context with respect to $\pi_2$
    ($\pi_2 \preceq \pi_1$);    
  \item There is a PDRS-context $\pi_{1'}$, such that $\pi_1$ subordinates
    $\pi_{1'}$ and $\pi_{1'}$ subordinates $\pi_2$.
\end{itemize}
\end{definition}

\noindent Again, we see a strong correlation to the definition for DRS
subordination (Definition~\ref{def:DRSsub}), with the addition of minimally
accessible contexts as possible subordinating contexts. Direct subordination for
PDRSs is defined as follows:

\begin{definition}[PDRS-context Direct Subordination]~\\
PDRS-context $\pi_i$ directly subordinates PDRS-context $\pi_j$ 
($\pi_j <!~\pi_i$) iff:
  \begin{itemize}
    \item $\langle\pi_i,\neg P_j\rangle$,
      $\langle\pi_i,\Box P_j\rangle$,
      or $\langle\pi_i,\Diamond P_j\rangle$ is a projected condition in
      some PDRS $P_k$, and $\rho(P_j) = \pi_j$;
    \item $\langle\pi_i,x:P_j\rangle$ is a projected condition in some
      PDRS $P_k$, for some $x$, and $\rho(P_j) = \pi_j$;
    \item  $\langle\pi_i,P_j \Rightarrow P_{j'}\rangle$ or
      $\langle\pi_i,P_j \vee P_{j'}\rangle$ is a projected condition in
      some PDRS $P_k$, and $\rho(P_j) = \pi_j$ or $\rho(P_{j'}) = \pi_j$;
    \item There is a PDRS $P_k$, such that $P_i \Rightarrow P_j$ or 
      $P_i \vee P_j$ is a PDRS condition in $P_k$, and $\rho(P_i) = \pi_i$ 
      and $\rho(P_j) = \pi_j$. 
    %NB this is about PDRS condition instead of projected condition
  \end{itemize}
\end{definition}

\noindent Note that direct subordination for PDRS-contexts is not defined on
the basis of the set of conditions of some PDRS, as is the case for DRS
subordination in Definition~\ref{def:DRSsub}, but on the basis of the
pointer associated with the PDRS condition in which the sub-PDRS occurs.
This is because pointers indicate where some content is interpreted, which
is relevant for determining accessibility between contexts. This means that
some sub-PDRS that is part of the conditions of another PDRS, need not be
subordinated by it. 

Finally, we define minimally accessible PDRS contexts as those dependencies
made explicit in the \MAPs, plus the cases in which some projected context
occurs free.

\begin{definition}[Minimally Accessible PDRS-Contexts]~\\
PDRS-context $\pi_i$ is a minimally accessible context with
respect to PDRS-context $\pi_j$ ($\pi_j \preceq \pi_i$) iff:
  \begin{itemize}
    \item $\langle \pi_2,\pi_1\rangle$ is an element of the set of
      \MAPs~of some PDRS $P_i$;
    \item There is some PDRS $P_i$, such that $\pi_1$ is introduced in $P_i$
      and $\rho(P_i)=\pi_2$, and $\pi_1$ is free in $P_i$. 
      %There is a PDRS $P_i$, such that $\rho(P_i) = \pi_2$ and 
      %$\pi_1 \in PVars(P_i)$, and there is no PDRS $P_j$, such that 
      %$\pi_2 \leq \rho(P_j)$ and $\rho(P_j) = \pi_1$;
       %%$\pi_1$ is introduced in (some sub-PDRS of) $\pi_2$, and $\pi_1$ 
       %%is free w.r.t. $\pi_2$;
  \end{itemize}
\end{definition}

The $\leq$-relation creates a partial order over all PDRS-contexts, provided
that subordination is defined for all projected contexts via the \MAPs. This
results in a directed graph, called the \textit{Accessibility Graph}, over
all PDRS-contexts in a given PDRS. We will call a PDRS whose accessibility
graph is weakly connected,\footnote{A directed graph $G$ is weakly connected
  iff for all pairs of vertices ($v_1$,$v_2$) in $G$ it holds that if all
  directed edges in $G$ are replaced by undirected edges, then there is
a path between $v_1$ and $v_2$.} a \emph{connected} PDRS. We will assume
that all PDRSs are complete throughout the rest of this paper, unless stated
otherwise.
%XXX Can we/Do we want to allow non-connected PDRSs in this sense? Yes: only
%in case of unresolved Merges (but then watch out for accidental bindings!)
%%XXX Define properly in Sandbox 
% All basic PDRSs are connected PDRSs. 


%resolved PDRS (no projected contexts): accessibility graph becomes tree.

\subsection{Variable binding}

Now we are ready to define free and bound variables.  This is necessary to
define projection, anaphoric binding, PDRS renaming, etc.

\begin{definition}[DRS bound variables]~\\
DRS variable $x$, introduced in DRS $K_i$, is bound iff:
\begin{quote}
There exists a DRS $K_j$, such that
\begin{enumerate}[i.]
  \item $K_i \leq K_j$;
  \item $x\in U(K_j)$. %, where $U(K_2)$ refers to the universe of $K_2$.
\end{enumerate}
\end{quote}
\end{definition}

\begin{definition}[PDRS bound projection variables]~\\
Projection variable $v$, introduced in PDRS $P_i$, is bound iff:
\begin{quote}
There exists a PDRS $P_j$, such that
\begin{enumerate}[i.]
  \item $\rho(P_i) \leq \rho(P_j)$; %remember that subordination for PDRSs was defined over PDRS-contexts
  \item $v = \rho(P_j)$.
\end{enumerate}
\end{quote}
\end{definition}

\begin{definition}[PDRS bound projected referents]~\\
Projected referent $\langle p,r\rangle$, introduced in PDRS $P_i$, is bound
iff:
\begin{quote}
There exists a PDRS-context $\pi_j$, such that
\begin{enumerate}[i.]
  \item $p \leq \pi_j$; 
%  \item $\rho(P_i) \leq \pi_j$; 
    %XXX is this by definition true, since $\rho(P_i) \leq p$ (given a
    %connected PDRS)?
  \item There exists some PDRS $P_j$, such that 
    $\langle \pi_j,r\rangle \in U(P_j)$.
\end{enumerate}
\end{quote}
\end{definition}

\subsection{Combining Structures}

Combining two DRSs simply means taking the union of the sets of referents
and conditions from both DRSs. One important condition on combing structures
is that no accidental binding of variables occurs. To see this, consider the
following example:

\ex. John smiles. Mary cries.\\
  \drs{x}{John(x)\\ smiles(x)} $\Cup$ \drs{x}{Mary(x)\\cries(x)} = 
  \drs{x}{John(x)\\ smiles(x)\\ Mary(x)\\ cries(x)}

\noindent This example illustrates that simply taking the set-theoretic
union of two DRSs may result in the wrong interpretation, since the
resulting DRS in \Last only introduces one referent, with four properties,
whereas the desired interpretation introduces two referents with each two
properties. In order to overcome this, we define a renaming function
$\mathcal{R}(K_1,K_2)$, which renames all (bound) variables in DRS $K_1$
which overlap with any variables occurring in $K_2$. %\footnote{The renaming
%function $\mathcal{R}$ is simply $\alpha$-conversion based on a fixed set
%of variables.} 
Since only bound variables are renamed, this function still allows for
anaphoric binding between DRSs, since variables that occur free will not be
renamed and may thus become bound. The resulting definition for DRS Merge is
shown below:

\begin{definition}[DRS Merge]~\\
Given DRSs $K_i=\langle U_i,C_i \rangle$ and $K_j=\langle U_j,C_j \rangle$,
the DRS merge between $K_i$ and $K_j$ ($K_i + K_j$) is defined as follows:
  \begin{quote}
    $K_i + K_j = 
    \langle U_i\cup U_{j'},C_i \cup C_{j'}\rangle$
  \end{quote}
  where: $K_{j'} = \langle U_{j'},C_{j'} \rangle = \mathcal{R}(K_j,K_i)$
\end{definition}

In PDRT, the projection variables should be taken into account when
combining structures.  In line with \citeasnoun{venhuizen2013iwcs} we can
define different types of merge for asserted and projected
content.\footnote{We here leave out the third merge for CI content described
in \citeasnoun{venhuizen2013iwcs}, since we have recently defined a new
analysis for CIs in PDRT that does not adhere to a special type of merge
\cite{venhuizenInPrepSALT}.} More specifically, ``assertive merge'' is an
operation between two PDRSs $P_1$ and $P_2$, which results a DRS in which
the asserted content of both $P_1$ and $P_2$ remains asserted. This is
effectuated by replacing all occurrences of the label of $P_1$ in the
universe and conditions of $P_1$ by the label of the resulting PDRS, that
is, by the label of (the renamed version of) $P_2$. The definition for
assertive merge is shown below. Here $S[v_1\backslash v_2]$ means that all
occurrences of $v_1$ in $S$ are replaced by $v_2$. Again, the renaming
function $\mathcal{R}$ renames all bound variables (projection variables and
DRS referents) in the first PDRS that overlap with variables in the second
PDRS.

\begin{definition}[PDRS Assertive Merge]~\\
Given PDRSs $P_i=\langle \rho_i,M_i,U_i,C_i \rangle$ and
$P_j=\langle \rho_j,M_j,U_j,C_j \rangle$, the assertive merge between $P_i$
and $P_j$ ($P_i + P_j$) is defined as follows:
  \begin{quote}
    $P_i + P_j = 
      \langle \rho_{j'}, 
      M_{i}[\rho_1\backslash\rho_{j'}] \cup M_{j'},
      U_{i}[\rho_1\backslash\rho_{j'}] \cup U_{j'},
      C_{i}[\rho_1\backslash\rho_{j'}] \cup C_{j'}\rangle$
  \end{quote}
  where: $P_{j'} = \langle \rho_{j'}, M_{j'}, U_{j'}, C_{j'} \rangle =$
      $\mathcal{R}(P_j,P_i)$
\end{definition}

\noindent Note that assertive merge, unlike DRS merge, is a non-symmetrical
operation, meaning that the order of the arguments changes the outcome of
the operation. However, it is straightforward to show that changing the
order of the arguments results in an $\alpha$-equivalent PDRS, since the
only difference is that the projection variables and referents may be named
differently. This implies that the assertive merge operation is
interpretation-symmetrical, since the order of the arguments does not affect
the truth-values of the resulting PDRS.

The operation for assertive merge results in a PDRS where all content has
the same status as it had before merging. However, we are interested in
creating a formalism in which some content may become projected during
discourse construction.  Intuitively, projected content (and in particular
presupposed content) has a status that is prior to asserted content.
Therefore, we define ``projective merge'' as an operation that results in
the content of its first argument to become projected in the resulting PDRS.
This operation is very similar to the $\alpha$-operator introduced by
\cite{bos2003implementing}, taking into account the projection variables in
a PDRS. Projection in PDRT means that the pointer of the projected content
indicates some accessible PDRS-context, which may either be instantiated by
a higher PDRS, or it may be a context that is projected since the pointer is
not bound by any label. By defining projective merge in such a way that the
projected content keeps its own pointer, we allow the projection variables
to become bound in an accessible PDRS, just as in the case of anaphoric
binding in DRT via the use of free variables that are not renamed during
merging. Since we want the result of the projective merge to be a connected
PDRS, the only addition to taking the set-theoretic union of the content of
the projected PDRS and the (renamed) context PDRS, is that the resulting set
of \MAPs~is enhanced with a relation expressing the accessibility between
the resulting PDRS and the context created through projection, i.e.,
the label of the projected PDRS.

\begin{definition}[PDRS Projective Merge]~\\
Given PDRSs $P_i=\langle \rho_i,M_i,U_i,C_i \rangle$ and 
$P_j=\langle \rho_j,M_j,U_j,C_j\rangle$, the projective merge between $P_i$
and $P_j$ ($P_i \ast P_j$) is defined as follows:
  \begin{quote}
    $P_i \ast P_j = 
      \langle \rho_{j'}, 
        M_{i}\cup M_{j'}\cup\{\langle\rho_{j'},\rho_{i}\rangle\}, 
        U_{i}\cup U_{j'},C_{i} \cup C_{j'}\rangle$
  \end{quote}
  where: $P_{j'} = \langle \rho_{j'}, M_{j'}, U_{j'}, C_{j'} \rangle =$ 
      $\mathcal{R}(P_j,P_i)$
\end{definition}

Now that we have defined the merge operations, we can create complex (P)DRSs
by combining multiple simple (P)DRSs. However, these operations only allow
us to combine \emph{complete} structures, representing for example sentences
or propositions, but there is no way to build up structures from even
smaller building blocks, such as words, since the current framework is
simply not powerful enough to express the meaning of such constituents. For
this, we need a way to define unresolved structures that still need to be
combined with some additional content in order to form a complete PDRS.
Here, we follow \citeasnoun{muskens1996combining}, who defined Compositional
DRT, a formalism that combines the dynamic semantics of DRT with a Montague
style composition procedure.

\subsection{Unresolved Structures}

\citeasnoun{muskens1996combining}

\begin{table}
  \caption{PDRT representations for a set of lexical items.}
  \label{tab:lexPDRS}
  \centering
\begin{tabular}{| l | l | l |}
\hline
{\bf Item} & {\bf DRT Semantics} & {\bf PDRT Semantics}\\
\hline
a     & $\lambda p.\lambda q.(($\flatdrs{$x$}{} $~+~p(x))+q(x))$
      & $\lambda p.\lambda q.(($\flatpdrs{$1$}{$x_1$}{}{}$~+~p(x))+q(x))$\\
\hline
the   &
      & $\lambda p.\lambda q.(($\flatpdrs{$1$}{$x_1$}{}{}$~+~p(x))*q(x))$\\
\hline
John  &
      &  $\lambda p.($\flatpdrs{$1$}{$x_1$}{John$_1$($x$)}{}$~*~p(x))$\\
\hline
man   &
      & $\lambda x.$\flatpdrs{$1$}{}{man$_1$($x$)}{}\\
\hline
walks &
      & $\lambda p. \lambda q. (p(\lambda x. (
        $\flatpdrs{1}{$e_1$}{walk$_1$($e$), Theme$_1$($e,x$)}{}
        $+~q(e))))$\\
\hline
\end{tabular}
\end{table}
