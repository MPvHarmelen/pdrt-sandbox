\section{Building Projective Discourse Representation Structures}
\label{sec:building}

% nice introduction

\subsection{Basic Structures and Subordination}

We define basic DRSs following \citeasnoun{bos2003implementing}, with the
exception that equality between variables (i.e., $x_1=x_2$) is not
a separate DRS condition, but is treated as a variant of a 2-place predicate
(i.e., $R(x_1,x_2)$, where $R$ equals $=$). This definition basically
follows the definition proposed by \citeasnoun{kamp1993discourse}, without
their duplex conditions, in order to allow for a direct translation to
first-order logic.

\begin{definition}[Basic DRS] \label{def:bDRS}~\\
A Basic DRS is a tuple $\langle \{x_1 ... x_n\},\{\gamma_1 ... \gamma_m\} 
\rangle$, where:
 \begin{enumerate}[i.]
  \item $\{x_1 ... x_n\}$ is a finite set of variables (called ``DRS
    referents'');
  \item $\{\gamma_1 ... \gamma_m\}$ is a finite set of DRS conditions (which
    may be either basic or complex);
  \item\label{def:bDRS:Rel} $R(x_1, ..., x_n)$ is a basic DRS condition,
    with $x_1 ... x_n$ are variables and $R$ is a relation symbol for an
    $n$-place predicate;
  \item $\neg K$, $\Box K$ and $\Diamond K$ are complex DRS conditions, with
    $K$ is a DRS;
  \item $K_1 \vee K_2$ and $K_1 \Rightarrow K_2$ are complex DRS conditions,
    with $K_1$ and $K_2$ are DRSs;
  \item \label{def:bDRS:Prop} $x:K$ is a complex DRS condition, with $x$ is
    a variable and $K$ is a DRS.
 \end{enumerate} 
\end{definition}

% set of referents is DRS universe
%%more explanation?

The main difference between a basic DRS and a basic PDRS is that in PDRT all
structures introduce a label, which can accordingly bind the pointers
associated with the PDRS referents and conditions. We will refer to labels
and pointers together as \textit{projection variables}. This description
results in the definition of a PDRS as a triple of a projection variable,
a set of projected referents (i.e., DRS referents associated with a pointer)
and a set of projected conditions. However, such a definition omits an
essential part of the information that is required to properly represent
projection phenomena, namely their \emph{projection path}. In DRT, the
projection path (or ``projection line'', as
\citeasnoun{sandt1992presupposition} calls it) of some projected content
determines which DRSs are accessible from the introduction site to find
a possible antecedent in or otherwise to accommodate into. Accessibility
between DRSs is standardly defined based on a subordination relation
($\leq$) between DRSs, i.e., DRS $K_1$ is accessible from DRS $K_2$
\textit{iff} $K_2\leq K_1$, where subordination is recursively defined as
follows:

\begin{definition}[DRS Subordination]\label{def:DRSsub}~\\
DRS $K_1$ subordinates DRS $K_2$ ($K_2 \leq K_1$) iff:
  \begin{itemize}
    \item $K_1 = K_2$;
    \item $K_1$ directly subordinates $K_2$ ($K_2 <!~K_1$);
    \item There is a DRS $K_{1'}$, such that $K_{1'} \leq K_1$ and 
      $K_2 \leq K_{1'}$.
  \end{itemize}
  \end{definition}

\noindent Thus, a DRS is always subordinated by itself, and by any DRS that
directly, or indirectly subordinates it. Direct subordination between two
DRSs $K_1$ and $K_2$ means that $K_2$ is either part of a condition in
$K_1$, or that $K_1$ serves as its antecedent in some binary operation. This
is formally defined below.

\begin{definition}[DRS Direct Subordination]~\\
DRS $K_i$ directly subordinates DRS $K_j$ ($K_j <!~K_i$) iff:
  \begin{itemize}
    \item $\neg K_j$, $\Box K_j$ or $\Diamond K_j$ is a DRS condition in
      $K_i$;
    \item $x:K_j$ is a DRS condition in $K_i$ for some $x$;
    \item $K_j \Rightarrow K_k$, $K_k \Rightarrow K_j$, $K_j \vee K_k$, or 
      $K_k \vee K_j$ is a DRS condition in $K_i$ for some DRS $K_k$;
    \item There is a DRS $K_k$, such that $K_i \Rightarrow K_j$ or $K_i \vee K_j$
      is a DRS condition in $K_k$.
  \end{itemize}
\end{definition}

Now, for the accessibility relations in PDRT we need to take into
account the contexts introduced by the projection pointers.  In case
a pointer occurs free, it introduces a projected context, whose
accessibility conditions are undefined, except for the fact that this
context needs to be accessible from the context in which it was introduced,
since the interpretation site of some linguistic content is necessarily
accessible from its introduction site. Moreover, projected contexts may
subordinate other projected contexts, which happens for example in the case
of embedded presuppositions. So, in order to properly define the projection
path of projected content in PDRT, the subordination properties of projected
contexts should be explicitly part of the PDRS. We do this by enhancing each
PDRS with a set of \MAPs: Minimally Accessible Projected contexts, which are
basically tuples describing pairs of  subordinating contexts. This results
in the following definition of basic PDRSs:

\begin{definition}[Basic PDRS] \label{def:bPDRS}~\\
A Basic PDRS is a quadruple $\langle \rho, \{\mu_1 ... \mu_n\}, 
\{\delta_1 ... \delta_m\}, \{\chi_1 ... \chi_l\}\rangle$, where:
  \begin{enumerate}[i.]
    \item $\rho$ is a projection variable;
    \item $\{\mu_1 ... \mu_n\}$ is a finite set of \MAPs, with $\mu_i=\langle
      v_1,v_2\rangle$, and  $v_1$ and $v_2$ are projection variables;
    \item $\{\delta_1 ... \delta_m\}$ is a finite set of projected
      referents, with $\delta_j=\langle v_j, x_j\rangle$, such that $v_j$ is
      a projection variable, and $x_j$ is a DRS referent;
    \item $\{\chi_1 ... \chi_l\}$ is a finite set of projected conditions,
      with $\chi_k = \langle v_k,\gamma_k\rangle$, such that $v_k$ is a
      projection variable, and $\gamma_k$ is a PDRS condition (which may be
      either basic or complex);
    \item \label{def:bPDRS:Rel} $R(x_1, ..., x_n)$ is a basic PDRS condition,
      with $x_1 ... x_n$ are variables and $R$ is a relation symbol for an
      $n$-place predicate;
    \item $\neg P$, $\Box P$ and $\Diamond P$ are complex PDRS conditions,
      with $P$ is a PDRS;
    \item $P_1 \vee P_2$ and $P_1 \Rightarrow P_2$ are complex PDRS
      conditions, with $P_1$ and $P_2$ are PDRSs;
    \item\label{def:bPDRS:Prop} $x:P$ is a complex PDRS condition, with $x$
      is a variable and $P$ is a PDRS;
  \end{enumerate}
\end{definition}

\noindent Note the direct correspondence between Definition
\ref{def:bPDRS}(\ref{def:bPDRS:Rel}-\ref{def:bPDRS:Prop}) and Definition
\ref{def:bDRS}(\ref{def:bDRS:Rel}-\ref{def:bDRS:Prop}); the only difference
is that complex PDRS conditions contain subordinated PDRSs, and complex DRS
conditions contain subordinated DRSs.  The definition of projected referents
and projected conditions as tuples allows us to talk about the two elements
of the tuples separately; we refer to the first element of all projected
referents and projected conditions as the \textit{pointer}, and the second
elements are called the \textit{PDRS referent} and \textit{PDRS condition},
respectively. This is useful, since in some cases we are interested in the
entire projected referent/condition, whereas in other cases we need only to
refer to one of the elements of the tuple. Similarly, we refer to the first
element of the quadruple representing a PDRS, as the \textit{label} of the
PDRS (formally, the label of a PDRS $P_i$ is represented as $\rho(P_i)$).

Now we can define subordination for PDRSs. As described above, we need to
consider both sub-PDRSs and projected contexts when defining accessibility.
Therefore, we define accessibility over \textit{PDRS-contexts} instead of
PDRSs. A PDRS-context may refer to a PDRS (via its label), or to a projected
context created by a pointer. PDRS subordination is then defined as follows:

\begin{definition}[PDRS-context Subordination]~\\
PDRS-context $\pi_1$ subordinates PDRS-context $\pi_2$ ($\pi_2 \leq \pi_1$)
iff:
\begin{itemize}
  \item $\pi_1 = \pi_2$;
  \item $\pi_1$ directly subordinates $\pi_2$ ($\pi_2 <!~\pi_1$);
  \item $\pi_1$ is a minimally accessible context with respect to $\pi_2$
    ($\pi_2 \preceq \pi_1$);    
  \item There is a PDRS-context $\pi_{1'}$, such that $\pi_1$ subordinates
    $\pi_{1'}$ and $\pi_{1'}$ subordinates $\pi_2$.
\end{itemize}
\end{definition}

\noindent Where the definition for direct subordination is defined over
PDRS-contexts, which means that direct subordination is defined on the basis
of the pointer associated with the PDRS condition in which the sub-PDRS
occurs, and not on the basis of the set of conditions of some PDRS, as is
the case for DRS subordination (see Definition~\ref{def:DRSsub}).  This is
because the pointers indicate where some content is interpreted, which is
relevant for determining accessibility between contexts.

\begin{definition}[PDRS-context Direct Subordination]~\\
PDRS-context $\pi_i$ directly subordinates PDRS-context $\pi_j$ 
($\pi_j <!~\pi_i$) iff:
  \begin{itemize}
    \item $\langle\pi_i,\neg P_j\rangle$,
      $\langle\pi_i,\Box P_j\rangle$,
      or $\langle\pi_i,\Diamond P_j\rangle$ is a projected condition in
      some PDRS $P_k$, and $\rho(P_j) = \pi_j$;
    \item $\langle\pi_i,x:P_j\rangle$ is a projected condition in some
      PDRS $P_k$, for some $x$, and $\rho(P_j) = \pi_j$;
    \item  $\langle\pi_i,P_j \Rightarrow P_{j'}\rangle$ or
      $\langle\pi_i,P_j \vee P_{j'}\rangle$ is a projected condition in
      some PDRS $P_k$, and $\rho(P_j) = \pi_j$ or $\rho(P_{j'}) = \pi_j$;
    \item There is a PDRS $P_k$, such that $P_i \Rightarrow P_j$ or 
      $P_i \vee P_j$ is a PDRS condition in $P_k$, and $\rho(P_i) = \pi_i$ 
      and $\rho(P_j) = \pi_j$. 
    %NB this is about PDRS condition instead of projected condition
  \end{itemize}
\end{definition}


Finally, we define minimally accessible PDRS contexts as those dependencies
made explicit in the \MAPs, plus the cases in which some projected context
occurs free.

\begin{definition}[Minimally Accessible PDRS-Contexts]~\\
PDRS-context $\pi_i$ is a minimally accessible context with
respect to PDRS-context $\pi_j$ ($\pi_j \preceq \pi_i$) iff:
  \begin{itemize}
    \item $\langle \pi_2,\pi_1\rangle$ is an element of the set of
      \MAPs~of some PDRS $P_i$;
    \item There is some PDRS $P_i$, such that $\pi_1$ is introduced in $P_i$
      and $\rho(P_i)=\pi_2$, and $\pi_1$ is free in $P_i$. 
      %There is a PDRS $P_i$, such that $\rho(P_i) = \pi_2$ and 
      %$\pi_1 \in PVars(P_i)$, and there is no PDRS $P_j$, such that 
      %$\pi_2 \leq \rho(P_j)$ and $\rho(P_j) = \pi_1$;
       %%$\pi_1$ is introduced in (some sub-PDRS of) $\pi_2$, and $\pi_1$ 
       %%is free w.r.t. $\pi_2$;
  \end{itemize}
\end{definition}

The $\leq$-relation creates a partial order over all PDRS-contexts. This
results in a directed graph, called the \textit{Accessibility Graph}, over
all PDRS-contexts in a given PDRS. We will call a PDRS whose accessibility
graph is weakly connected,\footnote{A directed graph $G$ is weakly connected
iff for all pairs of vertices ($v_1$,$v_2$) in $G$ it holds that if all
directed edges in $G$ are replaced by undirected edges, then there is a path
between $v_1$ and $v_2$.} a \emph{connected} PDRS. All basic PDRSs are
connected PDRss, because projection variables either occur free (in which
case they are accessible from their introduction site), or are bound by some
sub-PDRS, which is necessarily accessible from the global PDRS. We will see
that unresolved structures, introduced below, may result in accessibility
graphs that consist of multiple non-connected components.
%XXX unresolved Merges may result in a non-connected graph (but then watch
%out for accidental bindings!)
%%XXX Define properly in Sandbox 

%resolved PDRS (no projected contexts): accessibility graph becomes tree.

\subsection{Variable Binding}

Up to this point we have been talking informally about free and bound
referents and projection variables. DRT and PDRT are dynamic semantic
formalisms, which means that the meaning structures simultaneously provide
semantic content and serve as a context for novel information. That is, the
referents introduced in a (P)DRS may serve as antecedents for later
introduced anaphoric expressions. In DRT, a referent is bound in case it is
introduced in the universe of some accessible DRS, as formally defined below
(here, $U(K_i)$ indicates the set of referents in the universe of $K_i$).

\begin{definition}[DRS bound variables]~\\
DRS variable $x$, introduced in DRS $K_i$, is bound iff:
\begin{quote}
There exists a DRS $K_j$, such that
\begin{enumerate}[i.]
  \item $K_i \leq K_j$;
  \item $x\in U(K_j)$. %, where $U(K_2)$ refers to the universe of $K_2$.
\end{enumerate}
\end{quote}
\end{definition}

In PDRT, subordination was defined over PDRS-contexts (see
Definition~\ref{def:PDRSsub}), which makes sure that we allow
non-hierarchical binding through projection.

\begin{definition}[PDRS bound projected referents]~\\
Projected referent $\langle p,r\rangle$, introduced in PDRS $P_i$, is bound
iff:
\begin{quote}
There exists a PDRS-context $\pi_j$, such that
\begin{enumerate}[i.]
  \item $p \leq \pi_j$; 
%  \item $\rho(P_i) \leq \pi_j$; 
    %XXX is this by definition true, since $\rho(P_i) \leq p$ (given a
    %connected PDRS)?
  \item There exists some PDRS $P_j$, such that 
    $\langle \pi_j,r\rangle \in U(P_j)$.
\end{enumerate}
\end{quote}
\end{definition}

\begin{definition}[PDRS bound projection variables]~\\
Projection variable $v$, introduced in PDRS $P_i$, is bound iff:
\begin{quote}
There exists a PDRS $P_j$, such that
\begin{enumerate}[i.]
  \item $\rho(P_i) \leq \rho(P_j)$; 
  \item $v = \rho(P_j)$.
\end{enumerate}
\end{quote}
\end{definition}


\subsection{Combining Structures}

Combining two DRSs simply means taking the union of the sets of referents
and conditions from both DRSs. One important condition on combing structures
is that no accidental binding of variables occurs. To see this, consider the
following example:

\ex. John smiles. Mary cries.\\
  \drs{x}{John(x)\\ smiles(x)} $\Cup$ \drs{x}{Mary(x)\\cries(x)} = 
  \drs{x}{John(x)\\ smiles(x)\\ Mary(x)\\ cries(x)}

\noindent This example illustrates that simply taking the set-theoretic
union of two DRSs may result in the wrong interpretation, since the
resulting DRS in \Last only introduces one referent, with four properties,
whereas the desired interpretation introduces two referents with each two
properties. In order to overcome this, we define a renaming function
$\mathcal{R}(K_1,K_2)$, which renames all (bound) variables in DRS $K_1$
which overlap with any variables occurring in $K_2$. %\footnote{The renaming
%function $\mathcal{R}$ is simply $\alpha$-conversion based on a fixed set
%of variables.} 
Since only bound variables are renamed, this function still allows for
anaphoric binding between DRSs, since variables that occur free will not be
renamed and may thus become bound. The resulting definition for DRS Merge is
shown below:

\begin{definition}[DRS Merge]~\\
Given DRSs $K_i=\langle U_i,C_i \rangle$ and $K_j=\langle U_j,C_j \rangle$,
the DRS merge between $K_i$ and $K_j$ ($K_i + K_j$) is defined as follows:
  \begin{quote}
    $K_i + K_j = 
    \langle U_i\cup U_{j'},C_i \cup C_{j'}\rangle$
  \end{quote}
  where: $K_{j'} = \langle U_{j'},C_{j'} \rangle = \mathcal{R}(K_j,K_i)$
\end{definition}

In PDRT, the projection variables should be taken into account when
combining structures.  In line with \citeasnoun{venhuizen2013iwcs} we can
define different types of merge for asserted and projected
content.\footnote{We here leave out the third merge for CI content described
in \citeasnoun{venhuizen2013iwcs}, since we have recently defined a new
analysis for CIs in PDRT that does not adhere to a special type of merge
\cite{venhuizenInPrepSALT}.} More specifically, ``assertive merge'' is an
operation between two PDRSs $P_1$ and $P_2$, which results a DRS in which
the asserted content of both $P_1$ and $P_2$ remains asserted. This is
effectuated by replacing all occurrences of the label of $P_1$ in the
universe and conditions of $P_1$ by the label of the resulting PDRS, that
is, by the label of (the renamed version of) $P_2$. The definition for
assertive merge is shown below. Here $S[v_1\backslash v_2]$ means that all
occurrences of $v_1$ in $S$ are replaced by $v_2$. Again, the renaming
function $\mathcal{R}$ renames all bound variables (projection variables and
DRS referents) in the first PDRS that overlap with variables in the second
PDRS.

\begin{definition}[PDRS Assertive Merge]\label{def:amerge}~\\
Given PDRSs $P_i=\langle \rho_i,M_i,U_i,C_i \rangle$ and
$P_j=\langle \rho_j,M_j,U_j,C_j \rangle$, the assertive merge between $P_i$
and $P_j$ ($P_i + P_j$) is defined as follows:
  \begin{quote}
    $P_i + P_j = 
      \langle \rho_{j'}, 
      M_{i}[\rho_1\backslash\rho_{j'}] \cup M_{j'},
      U_{i}[\rho_1\backslash\rho_{j'}] \cup U_{j'},
      C_{i}[\rho_1\backslash\rho_{j'}] \cup C_{j'}\rangle$
  \end{quote}
  where: $P_{j'} = \langle \rho_{j'}, M_{j'}, U_{j'}, C_{j'} \rangle =$
      $\mathcal{R}(P_j,P_i)$
\end{definition}

\noindent Note that assertive merge, unlike DRS merge, is a non-symmetrical
operation, meaning that the order of the arguments changes the outcome of
the operation. However, it is straightforward to show that changing the
order of the arguments results in an $\alpha$-equivalent PDRS, since the
only difference is that the projection variables and referents may be named
differently. This implies that the assertive merge operation is
interpretation-symmetrical, since the order of the arguments does not affect
the truth-values of the resulting PDRS.

The operation for assertive merge results in a PDRS where all content has
the same status as it had before merging. However, we are interested in
creating a formalism in which some content may become projected during
discourse construction.  Intuitively, projected content (and in particular
presupposed content) has a status that is prior to asserted content.
Therefore, we define ``projective merge'' as an operation that results in
the content of its first argument to become projected in the resulting PDRS.
This operation is very similar to the $\alpha$-operator introduced by
\cite{bos2003implementing}, taking into account the projection variables in
a PDRS. Projection in PDRT means that the pointer of the projected content
indicates some accessible PDRS-context, which may either be instantiated by
a higher PDRS, or it may be a context that is projected since the pointer is
not bound by any label. By defining projective merge in such a way that the
projected content keeps its own pointer, we allow the projection variables
to become bound in an accessible PDRS, just as in the case of anaphoric
binding in DRT via the use of free variables that are not renamed during
merging. Since we want the result of the projective merge to be a connected
PDRS, the only addition to taking the set-theoretic union of the content of
the projected PDRS and the (renamed) context PDRS, is that the resulting set
of \MAPs~is enhanced with a relation expressing the accessibility between
the resulting PDRS and the context created through projection, i.e.,
the label of the projected PDRS.

\begin{definition}[PDRS Projective Merge]\label{def:pmerge}~\\
Given PDRSs $P_i=\langle \rho_i,M_i,U_i,C_i \rangle$ and 
$P_j=\langle \rho_j,M_j,U_j,C_j\rangle$, the projective merge between $P_i$
and $P_j$ ($P_i \ast P_j$) is defined as follows:
  \begin{quote}
    $P_i \ast P_j = 
      \langle \rho_{j'}, 
        M_{i}\cup M_{j'}\cup\{\langle\rho_{j'},\rho_{i}\rangle\}, 
        U_{i}\cup U_{j'},C_{i} \cup C_{j'}\rangle$
  \end{quote}
  where: $P_{j'} = \langle \rho_{j'}, M_{j'}, U_{j'}, C_{j'} \rangle =$ 
      $\mathcal{R}(P_j,P_i)$
\end{definition}

The merge operations provide a good handle for defining an incremental
construction procedure for (P)DRSs.


\subsection{Unresolved Structures}

The operations described so far allow for the combination of \emph{complete}
structures, representing for example sentences or propositions, but there is
no way to build up structures from even smaller building blocks, such as
words, since the current framework is simply not powerful enough to express
the meaning of such constituents. For this, we need a way to define
unresolved structures that still need to be combined with some additional
content in order to form a complete PDRS.  Here, we follow
\citeasnoun{muskens1996combining}, who defined Compositional DRT,
a formalism that combines the dynamic semantics of DRT with a Montague style
composition procedure.

In Compositional DRT (CDRT), each syntactic category can be defined using an
unresolved DRS, defined by means of lambda abstractions. For example, a noun
is considered to introduce a condition on a referent that still needs to be
defined, which can be represented as follows (using the flat representation
for DRSs): 

\ex. ``\textit{man}'':~~ $\lambda x.$\flatdrs{}{man($x$)}

When combined with a suitable referent, this unresolved DRS is transformed
into a resolved DRS with a free variable, which can become bound after
merging with a DRS that contains this variable in its universe. So, the
interaction between beta reduction (the elimination of lambda-terms) and
merge operations is crucial for obtaining proper DRSs. In CDRT, this
interaction is explicitly part of the lexical semantics associated with the
syntactic structures, as the unresolved structure representing the
determiner ``\textit{a}'' illustrates: 

\ex. ``\textit{a}'':~~ 
  $\lambda p.\lambda q.(($\flatdrs{$x$}{}$~+~p(x))+q(x))$

A determiner is thus defined as introducing a DRS with a single referent,
which needs to be merged with two unresolved DRSs in order to form
a completely resolved structure (i.e., a sentence), or, in type-theoretic
terms, a determiner is of the type: $(e\rightarrow t)\rightarrow
(e\rightarrow t) \rightarrow t$. Now we can apply beta reduction to create
the noun phrase ``\textit{a man}'', which will be of type $(e\rightarrow t)
\rightarrow t$:

\ex. ``\textit{a man}'':~~ 
  $\lambda p.\lambda q.(($\flatdrs{$x$}{}$~+~p(x))+q(x))$ ($\lambda x.$
  \flatdrs{}{man($x$)}$)~\stackrel{\beta}{=}~$ $\lambda q.($
  \flatdrs{$x$}{man($x$)}$~+~q(x))$ 

Based on these type-theoretic principles, we can define unresolved
structures for a wide range of lexical items, ranging from simple structures
for basic items like nouns, to more complex abstractions for particles or
prepositions, for example, since these introduce complex dependencies.  In
the same way, a compositional version of PDRT can be defined, in which the
unresolved structures contain PDRSs that are combined using assertive and
projective merge. With this machinery, we can deal with projection in
a straightforward and intuitive way on the lexical level: presupposition
triggers introduce a projective merge to insert their content in their local
context, instead of introducing a constant
\citeaffixed{kamp1993discourse,muskens1996combining}{cf.} or requiring
a post-hoc projection mechanism \citeaffixed{sandt1992presupposition}{cf.}
(but note the correspondence to the lexical DRS semantics defined by
\citeasnoun{bos2003implementing} using the $\alpha$-operator).  For example,
a name like ``\emph{John}'' is a noun phrase that introduces
a presupposition about the existence of an entity named `John'; this can be
represented by means of a lambda-term of type $(e\rightarrow t)\rightarrow
t$, with a projective merge to combine the PDRS that introduces `John' with
the unresolved structure:

\ex. ``\textit{John}'':~~ 
  $\lambda p.($\flatpdrs{$1$}{$1\gets x$}{$1\gets$John($x$)}{}$~*~p(x))$

When combined with a term of type $e\rightarrow t$, the pointer associated
with `John' ($1$ in the example above) will become free because by
definition of projective merge it is not renamed to match the label of the
context PDRS (see Definition~\ref{def:pmerge}). Note, however, that the
presupposition may still become bound in the larger discourse, when part of
a PDRS that is combined with an antecedent PDRS that matches its label. This
implies that determining the projection site of a presupposition is part of
constructing its lexical semantics, which makes sense in the light of the
context-dependency of meaning. 

Table~\ref{tab:lexPDRS} shows the unresolved PDRSs for a set of basic
lexical items. The examples illustrate that the interchanging of assertive
and projective merge nicely captures the correspondence between projecting
and non-projecting sibling items, such as the determiners ``\textit{a}'' and
``\textit{the}''. In section~\ref{sec:operations}, we will discuss some more
(operations on) lexical semantics, and in section~\ref{sec:playing} we will
come back to the issue of determining the right projection site for
projected content. %XXX Wel doen!

\begin{table}
  \caption{PDRT representations for a set of lexical items.}
  \label{tab:lexPDRS}
  \centering\small
\begin{tabular}{| l | c  | c |}
\hline
{\bf\normalsize Item}  & {\bf\normalsize Category} & 
  {\bf\normalsize PDRT Semantics}\\
\hline
\normalsize{a}       & DET & 
  $\lambda p.\lambda q.(($\pdrs{$1$}{$1\gets x$}{}{}$~+~p(x))+q(x))$\\
%\hline
\normalsize{the}     & DET & 
  $\lambda p.\lambda q.(($\pdrs{$1$}{$1\gets x$}{}{}$~+~p(x))*q(x))$\\
%\hline
\normalsize{dog}     & N  & 
  $\lambda x.$(\pdrs{$1$}{}{$1\gets$dog($x$)}{})\\
%\hline
\normalsize{John}    & NP & 
  $\lambda p.($\pdrs{$1$}{$1\gets x$}{$1\gets$John($x$)}{}$~*~p(x))$\\
%\hline
\normalsize{happy}   & ADJ &  
  $\lambda p. \lambda x.($\pdrs{$1$}{$1\gets e$}{$1\gets$happy($e$)\\
    $1\gets$Patient($e,x$)}{}$~+~p(x))$\\
%\hline
\normalsize{his}     & POS & 
  $\lambda p.\lambda q. \lambda r.((q(\lambda x.($\pdrs{$1$}{$1\gets y$}{
    $1\gets$male($x$)\\ $1\gets$of($y,x$)}{}$))~+~p(y))~*~r(y))$\\
%\hline
\normalsize{bark}    & V & 
  $\lambda p. \lambda q. (p(\lambda x. ($\pdrs{1}{$1\gets e$}{
    $1\gets$walk($e$)\\ $1\gets$Theme($e,x$)}{}$+~q(e))))$\\
%\hline
\normalsize{love}    & V & 
  $\lambda p. \lambda q.\lambda r. (q(\lambda x. (p(\lambda y.($\pdrs{1}{
    $1\gets e$}{$1\gets$love($e$)\\ $1\gets$Experiencer($e,x$)\\ 
    $1\gets$Stimulus($e,y$)}{}$+~r(e))))))$\\
%\hline
\normalsize{believe} & V & 
  $\lambda p. \lambda q. \lambda r. (q(\lambda x.($\pdrs{$1$}{$1\gets e$
    ~~$1\gets k$}{$1\gets$believe($e$)\\ $1\gets$Agent($e,x$)\\
    $1\gets$Theme($e,k$)\\ $1\gets k:(p(\lambda y.($\flatpdrs{$2$}{~}{~}{~}$))
    ~+~p(\lambda z.($\flatpdrs{$3$}{~}{~}{~}))}{}$~+~r(e))))$\\
%\hline
\normalsize{know}    & V & 
  $\lambda p. \lambda q. \lambda r. (q(\lambda x.($\pdrs{$1$}{$1\gets e$
    ~~$1\gets k$}{$1\gets$know($e$)\\ $1\gets$Agent($e,x$)\\
    $1\gets$Theme($e,k$)\\ $1\gets k:(p(\lambda y.($\flatpdrs{$2$}{~}{~}{~}$))
    ~*~p(\lambda z.($\flatpdrs{$3$}{~}{~}{~}))}{}$~+~r(e))))$\\
\hline
\end{tabular}
\end{table}
